{"parentSha1":"bd467f809ce2a42bd342fce03ff7fd2bd3d8446c","path":"answers-db/books/Category Theory For Programmers/8. Functoriality","item":{"title":"8. Functoriality","attr":{},"sha1":"e18a03b36be491917b35e3ce842e24b63f14db64"},"kids":[{"title":"6","attr":{"q":"<p>Should <code>std::map</code> be considered a bifunctor or a profunctor in the two template arguments <code>Key</code> and <code>T</code>? How would you redesign this data type to make it so?</p>","a":"<p>A function type <code>Key -&gt; T</code> would be a profunctor. But <code>std::map&lt;Key, T&gt;</code> is not a function. It's very similar though. If only we could set a default value for unknown key in <code>std::map</code> (currently it's not supported). But it's not hard to define a new data structure works that way. One way would be overriding the operator <code>[]</code> and make it return a default value of <code>T</code>.</p>"},"sha1":"4ae0af11639caed492117082594357e3650844c3"},{"title":"1","attr":{"q":"<p>Show that the data type:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">Pair</span> a b <span class=\"ot\">=</span> <span class=\"dt\">Pair</span> a b</span></code></pre></div>\n<p>is a bifunctor. For additional credit implement all three methods of Bifunctor and use equational reasoning to show that these definitions are compatible with the default implementations whenever they can be applied.</p>","a":"<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">Pair</span> a b <span class=\"ot\">=</span> <span class=\"dt\">Pair</span> a b</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">instance</span> <span class=\"dt\">Bifunctor</span> <span class=\"dt\">Pair</span> <span class=\"kw\">where</span></span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>  bimap f g (<span class=\"dt\">Pair</span> a b) <span class=\"ot\">=</span> <span class=\"dt\">Pair</span> (f a) (g b) </span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>  <span class=\"co\">-- = first f (Pair a (g b))</span></span>\n<span id=\"cb1-6\"><a href=\"#cb1-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>  <span class=\"co\">-- = first f (second g (Pair a b))</span></span>\n<span id=\"cb1-7\"><a href=\"#cb1-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>  <span class=\"co\">-- = first f . second g (Pair a b)</span></span>\n<span id=\"cb1-8\"><a href=\"#cb1-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>  first f (<span class=\"dt\">Pair</span> a b) <span class=\"ot\">=</span> <span class=\"dt\">Pair</span> (f a) b</span>\n<span id=\"cb1-9\"><a href=\"#cb1-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>  <span class=\"co\">-- = Pair (f a) (id b)</span></span>\n<span id=\"cb1-10\"><a href=\"#cb1-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>  <span class=\"co\">-- = bimap f id (Pair a b)</span></span>\n<span id=\"cb1-11\"><a href=\"#cb1-11\" aria-hidden=\"true\" tabindex=\"-1\"></a>  second g (<span class=\"dt\">Pair</span> a b) <span class=\"ot\">=</span> <span class=\"dt\">Pair</span> a (g b)</span>\n<span id=\"cb1-12\"><a href=\"#cb1-12\" aria-hidden=\"true\" tabindex=\"-1\"></a>  <span class=\"co\">-- = Pair (id a) (g b)</span></span>\n<span id=\"cb1-13\"><a href=\"#cb1-13\" aria-hidden=\"true\" tabindex=\"-1\"></a>  <span class=\"co\">-- = bimap id g (Pair a b)</span></span></code></pre></div>"},"sha1":"500252aa96078ad7749049791bddc69d04baf65c"},{"title":"3","attr":{"q":"<p>Let's try another data structure. I call it a <code>PreList</code> because it's a precursor to a <code>List</code>. It replaces recursion with a type parameter <code>b</code>.</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">PreList</span> a b <span class=\"ot\">=</span> <span class=\"dt\">Nil</span> <span class=\"op\">|</span> <span class=\"dt\">Cons</span> a b</span></code></pre></div>\n<p>You could recover our earlier definition of a <code>List</code> by recursively applying <code>PreList</code> to itself (we'll see how it's done when we talk about fixed points). Show that <code>PreList</code> is an instance of Bifunctor.</p>","a":"<p>It is a sum type of <code>Nil</code> and <code>Cons a b</code>. <code>Cons a b</code> is no different to <code>Pair a b</code> which we just proved to be a bifunctor. So it's algebraic type on a bifunctor hence bifunctor.</p>"},"sha1":"b708644d0e1b0472e5e0705d12ef970c43788970"},{"title":"5","attr":{"q":"<p>Define a bifunctor in a language other than Haskell. Implement <code>bimap</code> for a generic pair in that language.</p>","a":"<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode typescript\"><code class=\"sourceCode typescript\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>interface Bifunctor<span class=\"op\">&lt;</span>A<span class=\"op\">,</span>B<span class=\"op\">&gt;</span> {</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"fu\">bimap</span><span class=\"op\">&lt;</span>X<span class=\"op\">,</span>Y<span class=\"op\">&gt;</span>(f<span class=\"op\">:</span> (A)<span class=\"kw\">=&gt;</span>X<span class=\"op\">,</span> g<span class=\"op\">:</span> (B)<span class=\"kw\">=&gt;</span>Y)<span class=\"op\">:</span> Bifunctor<span class=\"op\">&lt;</span>X<span class=\"op\">,</span>Y<span class=\"op\">&gt;;</span></span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>}</span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>class Pair<span class=\"op\">&lt;</span>A<span class=\"op\">,</span> B<span class=\"op\">&gt;</span> implements Bifunctor<span class=\"op\">&lt;</span>A<span class=\"op\">,</span> B<span class=\"op\">&gt;</span>{</span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>    a<span class=\"op\">:</span> A</span>\n<span id=\"cb1-6\"><a href=\"#cb1-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    b<span class=\"op\">:</span> B</span>\n<span id=\"cb1-7\"><a href=\"#cb1-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"kw\">constructor</span>(a<span class=\"op\">:</span> A<span class=\"op\">,</span> b<span class=\"op\">:</span> B) {</span>\n<span id=\"cb1-8\"><a href=\"#cb1-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>        this<span class=\"op\">.</span><span class=\"at\">a</span> <span class=\"op\">=</span> a<span class=\"op\">;</span></span>\n<span id=\"cb1-9\"><a href=\"#cb1-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>        this<span class=\"op\">.</span><span class=\"at\">b</span> <span class=\"op\">=</span> b<span class=\"op\">;</span></span>\n<span id=\"cb1-10\"><a href=\"#cb1-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>    }</span>\n<span id=\"cb1-11\"><a href=\"#cb1-11\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"fu\">bimap</span>(f<span class=\"op\">,</span> g) {</span>\n<span id=\"cb1-12\"><a href=\"#cb1-12\" aria-hidden=\"true\" tabindex=\"-1\"></a>        return <span class=\"kw\">new</span> <span class=\"fu\">Pair</span>(<span class=\"fu\">f</span>(this<span class=\"op\">.</span><span class=\"at\">a</span>)<span class=\"op\">,</span> <span class=\"fu\">g</span>(this<span class=\"op\">.</span><span class=\"at\">b</span>))</span>\n<span id=\"cb1-13\"><a href=\"#cb1-13\" aria-hidden=\"true\" tabindex=\"-1\"></a>    }</span>\n<span id=\"cb1-14\"><a href=\"#cb1-14\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"fu\">greet</span>() {</span>\n<span id=\"cb1-15\"><a href=\"#cb1-15\" aria-hidden=\"true\" tabindex=\"-1\"></a>        <span class=\"fu\">return</span> <span class=\"vs\">`</span><span class=\"sc\">\\\\</span><span class=\"vs\">({this.a}:</span><span class=\"sc\">\\\\</span><span class=\"vs\">){typeof this.a} </span><span class=\"sc\">\\\\</span><span class=\"vs\">({this.b}:</span><span class=\"sc\">\\\\</span><span class=\"vs\">){typeof this.b}`</span></span>\n<span id=\"cb1-16\"><a href=\"#cb1-16\" aria-hidden=\"true\" tabindex=\"-1\"></a>    }</span>\n<span id=\"cb1-17\"><a href=\"#cb1-17\" aria-hidden=\"true\" tabindex=\"-1\"></a>}</span>\n<span id=\"cb1-18\"><a href=\"#cb1-18\" aria-hidden=\"true\" tabindex=\"-1\"></a>let p1 <span class=\"op\">=</span> <span class=\"kw\">new</span> <span class=\"fu\">Pair</span><span class=\"op\">&lt;</span><span class=\"dt\">number</span><span class=\"op\">,</span> <span class=\"dt\">boolean</span><span class=\"op\">&gt;</span>(<span class=\"dv\">3</span><span class=\"op\">,</span> true)</span>\n<span id=\"cb1-19\"><a href=\"#cb1-19\" aria-hidden=\"true\" tabindex=\"-1\"></a>let p2 <span class=\"op\">=</span> p1<span class=\"op\">.</span><span class=\"fu\">bimap</span>((x<span class=\"op\">:</span><span class=\"dt\">number</span>)<span class=\"op\">:</span><span class=\"dt\">string</span> <span class=\"kw\">=&gt;</span> x<span class=\"op\">.</span><span class=\"fu\">toString</span>()<span class=\"op\">,</span> (y<span class=\"op\">:</span><span class=\"dt\">boolean</span>)<span class=\"op\">:</span><span class=\"dt\">string</span> <span class=\"kw\">=&gt;</span> y<span class=\"op\">.</span><span class=\"fu\">toString</span>())</span>\n<span id=\"cb1-20\"><a href=\"#cb1-20\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"fu\">alert</span>(p2<span class=\"op\">.</span><span class=\"fu\">greet</span>())<span class=\"op\">;</span></span></code></pre></div>"},"sha1":"bccb3d9d8a349405f97dc7be4e2256c979bbbee9"},{"title":"4","attr":{"q":"<p>Show that the following data types define bifunctors in <code>a</code> and <code>b</code>:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">K2</span> c a b <span class=\"ot\">=</span> <span class=\"dt\">K2</span> c</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">Fst</span> a b <span class=\"ot\">=</span> <span class=\"dt\">Fst</span> a</span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">Snd</span> a b <span class=\"ot\">=</span> <span class=\"dt\">Snd</span> b</span></code></pre></div>\n<p>For additional credit, check your solutions agains Conor McBride's paper <a href=\"http://strictlypositive.org/CJ.pdf\">Clowns to the Left of me, Jokers to the Right</a>.</p>","a":"<p>Following code is same implementation as <a href=\"http://strictlypositive.org/CJ.pdf\" class=\"uri\">http://strictlypositive.org/CJ.pdf</a> (the referenced paper from the question.)</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">K2</span> c a b <span class=\"ot\">=</span> <span class=\"dt\">K2</span> c</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">Fst</span> a b <span class=\"ot\">=</span> <span class=\"dt\">Fst</span> a</span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">Snd</span> a b <span class=\"ot\">=</span> <span class=\"dt\">Snd</span> b</span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">instance</span> <span class=\"dt\">Bifunctor</span> (<span class=\"dt\">K2</span> c) <span class=\"kw\">where</span></span>\n<span id=\"cb1-6\"><a href=\"#cb1-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    bimap f g (<span class=\"dt\">K2</span> c) <span class=\"ot\">=</span> <span class=\"dt\">K2</span> c</span>\n<span id=\"cb1-7\"><a href=\"#cb1-7\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">instance</span> <span class=\"dt\">Bifunctor</span> <span class=\"dt\">Fst</span> <span class=\"kw\">where</span></span>\n<span id=\"cb1-8\"><a href=\"#cb1-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>    bimap f g (<span class=\"dt\">Fst</span> a) <span class=\"ot\">=</span> <span class=\"dt\">Fst</span> (f a)</span>\n<span id=\"cb1-9\"><a href=\"#cb1-9\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">instance</span> <span class=\"dt\">Bifunctor</span> <span class=\"dt\">Snd</span> <span class=\"kw\">where</span></span>\n<span id=\"cb1-10\"><a href=\"#cb1-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>    bimap f g (<span class=\"dt\">Snd</span> b) <span class=\"ot\">=</span> <span class=\"dt\">Snd</span> (g b)</span></code></pre></div>"},"sha1":"99a61cbe5dbf2efd2d797ddd7988b7d16087cd2b"},{"title":"2","attr":{"q":"<p>Show the isomorphism between the standard definition of Maybe and this desugaring:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> <span class=\"dt\">Maybe&#39;</span> a <span class=\"ot\">=</span> <span class=\"dt\">Either</span> (<span class=\"dt\">Const</span> () a) (<span class=\"dt\">Identity</span> a)</span></code></pre></div>\n<p>Hint: Define two mappings between the two implementations. For additional credit, show that they are the inverse of each other using equational reasoning.</p>","a":"<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">-- Equational reasoning between Maybe&#39; and Maybe is trivial. It writes itself.</span></span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> <span class=\"dt\">Maybe&#39;</span> a <span class=\"ot\">=</span> <span class=\"dt\">Either</span> (<span class=\"dt\">Const</span> () a) (<span class=\"dt\">Identity</span> a)</span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">maybeFrom ::</span> <span class=\"dt\">Maybe&#39;</span> a <span class=\"ot\">-&gt;</span> <span class=\"dt\">Maybe</span> a</span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>maybeFrom (<span class=\"dt\">Left</span> _) <span class=\"ot\">=</span> <span class=\"dt\">Nothing</span></span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>maybeFrom (<span class=\"dt\">Right</span> (<span class=\"dt\">Identity</span> a)) <span class=\"ot\">=</span> <span class=\"dt\">Just</span> a</span>\n<span id=\"cb1-6\"><a href=\"#cb1-6\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb1-7\"><a href=\"#cb1-7\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">maybeTo ::</span> <span class=\"dt\">Maybe</span> a <span class=\"ot\">-&gt;</span> <span class=\"dt\">Maybe&#39;</span> a</span>\n<span id=\"cb1-8\"><a href=\"#cb1-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>maybeTo <span class=\"dt\">Nothing</span> <span class=\"ot\">=</span> <span class=\"dt\">Left</span> (<span class=\"dt\">Const</span> ())</span>\n<span id=\"cb1-9\"><a href=\"#cb1-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>maybeTo (<span class=\"dt\">Just</span> a) <span class=\"ot\">=</span> <span class=\"dt\">Right</span> (<span class=\"dt\">Identity</span> a)</span></code></pre></div>"},"sha1":"c91840798b4dbb9abe84455bb6626710f43648ea"}]}