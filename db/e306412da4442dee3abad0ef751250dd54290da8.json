{"parentSha1":"bd467f809ce2a42bd342fce03ff7fd2bd3d8446c","path":"answers-db/books/Category Theory For Programmers/15. The Yoneda Lemma","item":{"title":"15. The Yoneda Lemma","attr":{},"sha1":"e306412da4442dee3abad0ef751250dd54290da8"},"kids":[{"title":"3","attr":{"q":"<p>A list of units <code>[()]</code> contains no other information but its length. So, as a data type, it can be considered an encoding of integers. An empty list encodes zero, a singleton <code>[()]</code> (a value, not a type) encodes one, and so on. Construct another representation of this data type using the Yoneda lemma for the list functor.</p>","a":"<p>If you give <code>()</code> as a to Yoneda lemma for the list functor, you get set of natural transformations from <code>C((), -)</code> to List that are isomorphic to <code>[()]</code>. So the data type of the natural transformations <code>(()-&gt;x)-&gt;[x]</code> could be another representation.</p>"},"sha1":"3f184d69913f8c9147c2fa28b2af86394a135fca"},{"title":"1","attr":{"q":"<p>Show that the two functions <code>phi</code> and <code>psi</code> that form the Yoneda isomorphism in Haskell are inverses of each other.</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">phi ::</span> (<span class=\"kw\">forall</span> x <span class=\"op\">.</span> (a <span class=\"ot\">-&gt;</span> x) <span class=\"ot\">-&gt;</span> <span class=\"dt\">F</span> x) <span class=\"ot\">-&gt;</span> <span class=\"dt\">F</span> a</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>phi alpha <span class=\"ot\">=</span> alpha <span class=\"fu\">id</span></span></code></pre></div>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb2-1\"><a href=\"#cb2-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">psi ::</span> <span class=\"dt\">F</span> a <span class=\"ot\">-&gt;</span> (<span class=\"kw\">forall</span> x <span class=\"op\">.</span> (a <span class=\"ot\">-&gt;</span> x) <span class=\"ot\">-&gt;</span> <span class=\"dt\">F</span> x)</span>\n<span id=\"cb2-2\"><a href=\"#cb2-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>psi fa h <span class=\"ot\">=</span> <span class=\"fu\">fmap</span> h fa</span></code></pre></div>","a":"<p>let <code>psi' fa = (flip fmap) fa</code> so <code>psi</code> and <code>phi</code>'s each input/output type match. (flip swaps the order of parameters)</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>phi (psi&#39; fa)</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">=</span> (psi&#39; fa) <span class=\"fu\">id</span></span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">=</span> ((<span class=\"fu\">flip</span> <span class=\"fu\">fmap</span>) fa) <span class=\"fu\">id</span></span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">=</span> <span class=\"fu\">fmap</span> <span class=\"fu\">id</span> fa</span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">=</span> fa</span></code></pre></div>"},"sha1":"53ebcf7af5a3c65007a8345f821b133f4be6262e"},{"title":"2","attr":{"q":"<p>A discrete category is one that has objects but no morphisms other than identity morphisms. How does the Yoneda lemma work for functors from such a category?</p>","a":"<p>Let <span class=\"math inline\">\\eta</span> be a natural transformation from <span class=\"math inline\">hom(X, -)</span> to <span class=\"math inline\">F X</span>. <span class=\"math inline\">\\eta_X</span> is a function of <span class=\"math inline\">\\eta_X : hom(X,X) \\rightarrow F X</span>. Since <span class=\"math inline\">hom(X,X)</span> is a singleton set, there are different <span class=\"math inline\">\\eta_X</span> as many as the cardinality of <span class=\"math inline\">F X</span>. In the mean time there is only one kind of <span class=\"math inline\">\\eta_A</span>, the <em>absurd</em> function , for any other component than <span class=\"math inline\">X</span> because <span class=\"math inline\">hom(X, A)</span> is empty. Therefore there are different <span class=\"math inline\">\\eta</span> as many as <span class=\"math inline\">F A</span>.</p>"},"sha1":"023f5bb88122c0c2c2df61b4ed52d0895f925aeb"}]}