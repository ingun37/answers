{"parentSha1":"bd467f809ce2a42bd342fce03ff7fd2bd3d8446c","path":"answers-db/books/Category Theory For Programmers/16. Yoneda Embedding","item":{"title":"16. Yoneda Embedding","attr":{},"sha1":"a66800b6db7ae336b8b1d850b23e8702403e9933"},"kids":[{"title":"1","attr":{"q":"<p>Express the co-Yoneda embedding in Haskell.</p>","a":"<p>It's asking to express following statement.</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">forall</span> x, (x <span class=\"ot\">-&gt;</span> a) <span class=\"ot\">-&gt;</span> (x <span class=\"ot\">-&gt;</span> b) <span class=\"op\">$</span> \\cong <span class=\"op\">$</span> a <span class=\"ot\">-&gt;</span> b</span></code></pre></div>\n<p>When the book was explaining yoneda embedding, it uncurried only the last <code>b</code>.<br />\nBut this time we will uncurry the whole <code>C(x, b)</code> part, which is the last two <code>x -&gt; b</code>. And also we will name the right hand side as <code>atob</code></p>\n<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb2-1\"><a href=\"#cb2-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">fromY ::</span> (x <span class=\"ot\">-&gt;</span> a) <span class=\"ot\">-&gt;</span> (x <span class=\"ot\">-&gt;</span> b)</span>\n<span id=\"cb2-2\"><a href=\"#cb2-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>fromY f <span class=\"ot\">-&gt;</span> atob <span class=\"op\">.</span> f</span></code></pre></div>\n<p>And the conversion is same.</p>\n<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb3-1\"><a href=\"#cb3-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>fromY<span class=\"ot\"> id ::</span> a <span class=\"ot\">-&gt;</span> b</span></code></pre></div>"},"sha1":"f0d90dcbf4a78affd0c27870648365e5968df4d6"},{"title":"3","attr":{"q":"<p>Work out the Yoneda embedding for a monoid. What functor corresponds to the monoid's single object? What natural transformations correspond to monoid morphisms?</p>","a":"<p>Monoid is a category with only one object. So there can be only one functor <code>C(x, -)</code>. And a natural transformations <span class=\"math inline\">\\alpha</span> that corresponds to a monoid morphism <code>m</code> would be just composition of <span class=\"math inline\">f \\in C(x, -)</span> with <code>m</code>. I don't know if it means other than just plain definition of monoid as it appears. If you know please contribute.</p>"},"sha1":"6ce08c7157d20230489067d52de8475b17d8b97f"},{"title":"5","attr":{"q":"<p>Yoneda embedding can be used to embed an arbitrary functor category <code>[C, D]</code> in the functor category <code>[[C, D], Set]</code>. Figure out how it works on morphisms (which in this case are natural transformations).</p>","a":"<p>They make vertical compositions. <code>(b -&gt; a) . (a -&gt; x) = b -&gt; x</code> If you know more, please <a href=\"https://github.com/ingun37/category-theory-for-programmers-answers\">contribute</a>.</p>"},"sha1":"b6a1a6f0e1f4fdd9ed05aedc4038ac29a060a6a0"},{"title":"4","attr":{"q":"<p>What is the application of the covariant Yoneda embedding to preorders? (Question suggested by Gershom Bazerman.)</p>","a":"<p>I think it's just dual version of contravariant Yoneda embedding nothing more. If you know, please <a href=\"https://github.com/ingun37/category-theory-for-programmers-answers\">contribute</a>.</p>"},"sha1":"853f550fef369d49b30fee6f68172f49b7304f58"},{"title":"2","attr":{"q":"<p>Show that the bijection we established between <code>fromY</code> and <code>btoa</code> is an isomorphism (the two mappings are the inverse of each other).</p>","a":"<p>Let <code>A</code> be a <code>fromY</code> function to which <code>B</code> is mapped. Let <code>B'</code> be the <code>A id</code> in other words <code>B'</code> is <code>btoa</code> function to which <code>A</code> is mapped. Now let <code>A'</code> be the <code>fromY</code> function to which <code>B'</code> is mapped. <code>A'</code> must be same to <code>A</code> if it's isomorphic.</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"dt\">A&#39;</span> f b <span class=\"ot\">=</span> f (<span class=\"dt\">B&#39;</span> b)</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">=</span> f (<span class=\"dt\">A</span> <span class=\"fu\">id</span> b)</span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">=</span> f (<span class=\"fu\">id</span> <span class=\"dt\">B</span> b)</span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"ot\">=</span> f (<span class=\"dt\">B</span> b)</span></code></pre></div>\n<p>It says <code>A'</code> is also mapped from <code>B</code> which means <code>B = B'</code> which means <code>A = A'</code></p>"},"sha1":"3f568a20ac38430ddb68908d0a34aa5d7b8677ee"}]}