{"parentSha1":"bd467f809ce2a42bd342fce03ff7fd2bd3d8446c","path":"answers-db/books/Category Theory For Programmers/18. Adjunctions","item":{"title":"18. Adjunctions","attr":{},"sha1":"7fe3168e57a9da2b597e912557c872cd0303917e"},"kids":[{"title":"2","attr":{"q":"<p>Derive the counit <span class=\"math inline\">\\varepsilon</span> starting from the hom-sets isomorphism in the second definition of the adjunction.</p>","a":"<p>The book already derived unit <span class=\"math inline\">\\eta</span> by replacing <span class=\"math inline\">c</span> with <span class=\"math inline\">Ld</span>. In the same way we can derive <span class=\"math inline\">\\varepsilon</span> by replacing <span class=\"math inline\">d</span> with <span class=\"math inline\">Rc</span>.<br />\nReplacing <span class=\"math inline\">d</span> with <span class=\"math inline\">Rc</span> gives us<br />\n<span class=\"math inline\">C(LRc,c) \\cong D(Rc,Rc)</span><br />\nThere's at least one morphism (<span class=\"math inline\">id</span>) in <span class=\"math inline\">D(Rc, Rc)</span> so there must be a corresponding morphism in <span class=\"math inline\">C(LRc,c)</span> which is the counit.</p>"},"sha1":"51720de77323032d8fef3dff7ed6d4759b361c1d"},{"title":"3","attr":{"q":"<p>Complete the proof of equivalence of the two definitions of the adjunction.</p>","a":"<p>So far we have derived unit and counit from hom-sets isomorphism and injectivity <span class=\"math inline\">C(Ld,c) \\rightarrow D(d,Rc)</span> from unit and counit. The only thing left to proove the equivalence is injectivity in the other way.<br />\nIn the book we derived injection <span class=\"math inline\">C(Ld,c) \\rightarrow D(d,Rc)</span> by lifting <span class=\"math inline\">f:Ld \\rightarrow c</span> with <span class=\"math inline\">R</span>. In the same way we can derive the other way injection <span class=\"math inline\">D(d,Rc) \\rightarrow C(Ld,c)</span> by lifting <span class=\"math inline\">g:d \\rightarrow Rc</span> with <span class=\"math inline\">L</span>.<br />\nLifted <span class=\"math inline\">Lg</span> can be composed with unit <span class=\"math inline\">\\eta</span> and make a morphism <span class=\"math inline\">Lg \\cdot \\eta: Ld \\rightarrow c</span>.</p>"},"sha1":"9120f6abd026909cb9cd565495abbffee7f20bd8"},{"title":"5","attr":{"q":"<p>Show that the coproduct is the left adjoint of the diagonal functor.</p>","a":"<p>Shown in 4.</p>"},"sha1":"9587b30430e646e6fefb71e8204ebe94051cf5c6"},{"title":"4","attr":{"q":"<p>Show that the coproduct can be defined by an adjuntion. Start with the definition of the factorizer for a coproduct.</p>","a":"<p>Coproduct functor as Left adjoint and square functor as right adjoint, we can build an adjunction like this.<br />\n<img src=\"/answers/imgs/IMG_4745A389AF18-1.jpeg\" /><br />\nBy definition of coproduct, <span class=\"math inline\">m</span> and pair of <span class=\"math inline\">&lt;p,q&gt;</span> must be isomorphic.<br />\nWe can define factorizer by composing counit <span class=\"math inline\">\\varepsilon</span> and <span class=\"math inline\">L&lt;p,q&gt;</span> and the inverse by composing <span class=\"math inline\">Rm</span> and unit <span class=\"math inline\">\\eta</span>.</p>"},"sha1":"5339c96121cbeeee75d375d64623fd2d5fda350d"},{"title":"6","attr":{"q":"<p>Define the adjunction between a product and a function object in Haskell.</p>","a":"<p>We are asked to define Exponential in Haskell.<br />\nFYI, it's not mentioned in the book but the Exponential that is described in the book is basically currying.</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>unit z a <span class=\"ot\">=</span> (z, a)</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>counit (f, a) <span class=\"ot\">=</span> f a</span></code></pre></div>"},"sha1":"5d84908466c4564550ad5440e3c4bd9f58135b2c"},{"title":"1","attr":{"q":"<p>Derive the naturality square for <span class=\"math inline\">\\psi</span>, the transformation between the two (contravariant) functors:</p>\n<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>a <span class=\"ot\">-&gt;</span> <span class=\"dt\">C</span>(<span class=\"dt\">L</span> a, b)</span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>b <span class=\"ot\">-&gt;</span> <span class=\"dt\">D</span>(a, <span class=\"dt\">R</span> b)</span></code></pre></div>","a":"<p>We are asked to make the red morphisms from given a random morphism <span class=\"math inline\">f : a \\rightarrow a&#39;</span></p>\n<p><img src=\"/answers/imgs/IMG_05FBAC45DBBD-1.jpeg\" /></p>\n<p>We can make <span class=\"math inline\">m</span> by composing <span class=\"math inline\">\\psi \\cdot g \\cdot Lf</span> where <span class=\"math inline\">g \\in C(La&#39;, b)</span><br />\nand <span class=\"math inline\">n</span> by composing <span class=\"math inline\">\\psi \\cdot f \\cdot h</span> where <span class=\"math inline\">h \\in D(a&#39;,Rb)</span></p>"},"sha1":"a0b4d68585c916b84d810f1231b7b0f4e0d740b5"}]}