{"parentSha1":"75df80b93928fc4dc6a1a61ed6d6c66766fdfcdb","path":"books/Category Theory For Programmers/8. Functoriality/5","kids":[],"item":{"attr":{"a":"```typescript\ninterface Bifunctor<A,B> {\n    bimap<X,Y>(f: (A)=>X, g: (B)=>Y): Bifunctor<X,Y>;\n}\nclass Pair<A, B> implements Bifunctor<A, B>{\n    a: A\n    b: B\n    constructor(a: A, b: B) {\n        this.a = a;\n        this.b = b;\n    }\n    bimap(f, g) {\n        return new Pair(f(this.a), g(this.b))\n    }\n    greet() {\n        return `$`{this.a}:`${typeof this.a} $`{this.b}:`${typeof this.b}`\n    }\n}\nlet p1 = new Pair<number, boolean>(3, true)\nlet p2 = p1.bimap((x:number):string => x.toString(), (y:boolean):string => y.toString())\nalert(p2.greet());\n```","q":"Define a bifunctor in a language other than Haskell. Implement `bimap` for a generic pair in that language."},"sha1":"69afb1768835cbcb691bd0ed1baa3449d0cbe268","title":"5"}}