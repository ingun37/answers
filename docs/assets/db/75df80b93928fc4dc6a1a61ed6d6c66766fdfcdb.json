{"parentSha1":"b614f31d04b3bc2b3d23ee4337475251429e5a9f","path":"books/Category Theory For Programmers/8. Functoriality","kids":[{"attr":{"a":"A function type `Key -> T` would be a profunctor. But `std::map<Key, T>` is not a function. It's very similar though. If only we could set a default value for unknown key in `std::map` (currently it's not supported). But it's not hard to define a new data structure works that way. One way would be overriding the operator `[]` and make it return a default value of `T`.","q":"Should `std::map` be considered a bifunctor or a profunctor in the two template arguments `Key` and `T`? How would you redesign this data type to make it so?"},"sha1":"b62fe47677352aa66777fa61d38d082b4546430f","title":"6"},{"attr":{"a":"```haskell\n-- Equational reasoning between Maybe' and Maybe is trivial. It writes itself.\ntype Maybe' a = Either (Const () a) (Identity a)\nmaybeFrom :: Maybe' a -> Maybe a\nmaybeFrom (Left _) = Nothing\nmaybeFrom (Right (Identity a)) = Just a\n\nmaybeTo :: Maybe a -> Maybe' a\nmaybeTo Nothing = Left (Const ())\nmaybeTo (Just a) = Right (Identity a)\n```","q":"Show the isomorphism between the standard definition of Maybe and this desugaring:\n```haskell\ntype Maybe' a = Either (Const () a) (Identity a)\n```\nHint: Define two mappings between the two implementations. For additional credit, show that they are the inverse of each other using equational reasoning."},"sha1":"e187d14871666eac448876f486af7d6b6e16f00f","title":"2"},{"attr":{"a":"It is a sum type of `Nil` and `Cons a b`. `Cons a b` is no different to `Pair a b` which we just proved to be a bifunctor. So it’s algebraic type on a bifunctor hence bifunctor.","q":"Let’s try another data structure. I call it a `PreList` because it’s a precursor to a `List`. It replaces recursion with a type parameter `b`.\n```haskell\ndata PreList a b = Nil | Cons a b\n```\nYou could recover our earlier definition of a `List` by recursively applying `PreList` to itself (we’ll see how it’s done when we talk about fixed points).\nShow that `PreList` is an instance of Bifunctor."},"sha1":"9309898cdbffb21cdf2c2a8faad51d01839948c5","title":"3"},{"attr":{"a":"```typescript\ninterface Bifunctor<A,B> {\n    bimap<X,Y>(f: (A)=>X, g: (B)=>Y): Bifunctor<X,Y>;\n}\nclass Pair<A, B> implements Bifunctor<A, B>{\n    a: A\n    b: B\n    constructor(a: A, b: B) {\n        this.a = a;\n        this.b = b;\n    }\n    bimap(f, g) {\n        return new Pair(f(this.a), g(this.b))\n    }\n    greet() {\n        return `${this.a}:${typeof this.a} ${this.b}:${typeof this.b}`\n    }\n}\nlet p1 = new Pair<number, boolean>(3, true)\nlet p2 = p1.bimap((x:number):string => x.toString(), (y:boolean):string => y.toString())\nalert(p2.greet());\n```","q":"Define a bifunctor in a language other than Haskell. Implement `bimap` for a generic pair in that language."},"sha1":"69afb1768835cbcb691bd0ed1baa3449d0cbe268","title":"5"},{"attr":{"a":"Following code is same implementation as http://strictlypositive.org/CJ.pdf (the referenced paper from the question.)\n```haskell\ndata K2 c a b = K2 c\ndata Fst a b = Fst a\ndata Snd a b = Snd b\n\ninstance Bifunctor (K2 c) where\n    bimap f g (K2 c) = K2 c\ninstance Bifunctor Fst where\n    bimap f g (Fst a) = Fst (f a)\ninstance Bifunctor Snd where\n    bimap f g (Snd b) = Snd (g b)\n```","q":"Show that the following data types define bifunctors in `a` and `b`:\n```haskell\ndata K2 c a b = K2 c\ndata Fst a b = Fst a\ndata Snd a b = Snd b\n```\nFor additional credit, check your solutions agains Conor McBride’s paper [Clowns to the Left of me, Jokers to the Right](http://strictlypositive.org/CJ.pdf)."},"sha1":"6ef02f0a35b100745d208db8fec26e61ad24aa71","title":"4"},{"attr":{"a":"```haskell\ndata Pair a b = Pair a b\n\ninstance Bifunctor Pair where\n  bimap f g (Pair a b) = Pair (f a) (g b) \n  -- = first f (Pair a (g b))\n  -- = first f (second g (Pair a b))\n  -- = first f . second g (Pair a b)\n  first f (Pair a b) = Pair (f a) b\n  -- = Pair (f a) (id b)\n  -- = bimap f id (Pair a b)\n  second g (Pair a b) = Pair a (g b)\n  -- = Pair (id a) (g b)\n  -- = bimap id g (Pair a b)\n```","q":"Show that the data type:\n```haskell\ndata Pair a b = Pair a b\n```\nis a bifunctor. For additional credit implement all three methods of Bifunctor and use equational reasoning to show that these definitions are compatible with the default implementations whenever they can be applied."},"sha1":"8bf9b6745c960b58650f160da9f7743045607792","title":"1"}],"item":{"attr":{},"sha1":"75df80b93928fc4dc6a1a61ed6d6c66766fdfcdb","title":"8. Functoriality"}}