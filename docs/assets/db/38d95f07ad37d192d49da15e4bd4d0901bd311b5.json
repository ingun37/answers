{"parentSha1":"b614f31d04b3bc2b3d23ee4337475251429e5a9f","path":"books/Category Theory For Programmers/14. Representable Functors","kids":[{"attr":{"a":"Yes. `Reader a` is `Hom(a, -)`\n","q":"Is the `Reader` functor representable?\n"},"sha1":"0e2049eb22ff1c98bdbc9c1cd680e0d0ab8a7d9b","title":"3"},{"attr":{"a":"```haskell\n{-# LANGUAGE TypeFamilies #-}\n\nimport Data.Functor\nimport Data.Functor.Contravariant\n\nclass Representable f where\n    type Rep f :: *\n    tabulate :: (Rep f -> x) -> f x \n    index :: f x -> Rep f -> x\n\ndata Stream x = Cons x (Stream x)\n\ninstance Representable Stream where\n    type Rep Stream = Int\n    tabulate f = Cons (f 0) (tabulate (f . (+1)))\n    index (Cons b bs) n = if n == 0 then b else index bs (n - 1)\n\nindexStream :: Stream x -> Int -> x\nindexStream = index\nsquared :: Int -> Int\nsquared = indexStream (tabulate (^2))\n\nmemoize :: (Int -> a) -> (Int -> a)\nmemoize f = (map f [0 ..] !!)\n\nsqMemo = memoize squared\n\nmain :: IO ()\nmain = print $ sqMemo 10\n```","q":"Using Stream representation, memoize a function that squares its argument.\n"},"sha1":"de53d7f24aca4ffbad618dbe732787cabc9e5f1d","title":"4"},{"attr":{"a":"```haskell\ndata Pair a = Pair a a\ninstance Representable Pair where\n    type Rep Pair = Bool\n    tabulate f = Pair (f True) (f False)\n    index (Pair x y) = \\b -> if b then x else y\n```","q":"The functor:\n\n`Pair a = Pair a a`\n\nis representable. Can you guess the type that represents it? Implement `tabulate` and `index`.\n"},"sha1":"809f468d6af197b3b6af567a45cf5564560fb1a6","title":"6"},{"attr":{"a":"$hom(a, -)$'s `fmap` would be `fmap f g = f . g`. Therefore `fmap id` would be `g = id . g` which is equal to `g = g`.\n\n$hom(-, a)$'s `contramap` would be `contramap f h = h . f`. Therefore `contramap id` would be `h = h . id` which is equal to `h = h`.","q":"Show that the hom-functors map identity morphisms in $C$ to corresponding identity functions in Set.\n"},"sha1":"ca33c868da55bdce8d164fb6cb85be611ef7b4e9","title":"1"},{"attr":{"a":"```haskell\n(index . tabulate f) 0\n= index (Cons (f 0) (tabulate (f . (+1)))) 0\n= f 0\n(index . tabulate f) n+1\n= index (Cons (f 0) (tabulate (f . (+1)))) n+1\n= index (tabulate (f . (+1))) (n)\n= index . tabulate g n\n= g n\n= f . (+1) n\n= f n+1\n```","q":"Show that `tabulate` and `index` for `Stream` are indeed the inverse of each other. (Hint: use induction.)\n"},"sha1":"d649e08d93a0c9bef7fa2a2469c97f3beac9d88e","title":"5"},{"attr":{"a":"To be representable, for all `x`, `Maybe x` and `Hom(a, x)` must have at least 1 bijective function. But `Maybe x` is $x + 1$ and `Hom(a, x)` is $x^a$. Hence it can't be representable.\n","q":"Show that `Maybe` is not representable.\n"},"sha1":"a2890b014b25a0efcc450a5fc5c8c2455d3a5c5c","title":"2"}],"item":{"attr":{},"sha1":"38d95f07ad37d192d49da15e4bd4d0901bd311b5","title":"14. Representable Functors"}}