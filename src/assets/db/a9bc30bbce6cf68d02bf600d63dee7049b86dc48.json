{"parentSha1":"b614f31d04b3bc2b3d23ee4337475251429e5a9f","path":"books/Category Theory For Programmers/16. Yoneda Embedding","kids":[{"attr":{"a":"Monoid is a category with only one object. So there can be only one functor `C(x, -)`. And a natural transformations $\\alpha$ that corresponds to a monoid morphism `m` would be just composition of $f \\in C(x, -)$ with `m`. I don't know if it means other than just plain definition of monoid as it appears. If you know please contribute.\n","q":"Work out the Yoneda embedding for a monoid. What functor corresponds to the monoidâ€™s single object? What natural transformations correspond to monoid morphisms?\n"},"sha1":"175fbfb7089e1231801b11775c632eae07d648c0","title":"3"},{"attr":{"a":"I think it's just dual version of contravariant Yoneda embedding nothing more. If you know, please [contribute](https://github.com/ingun37/category-theory-for-programmers-answers).\n","q":"What is the application of the covariant Yoneda embedding to preorders? (Question suggested by Gershom Bazerman.)\n"},"sha1":"36e54c7b8425d9757b9f94454300af0b2947225d","title":"4"},{"attr":{"a":"It's asking to express following statement.\n\nforall x, (x -> a) -> (x -> b) $\\cong$ a -> b\n\nWhen the book was explaining yoneda embedding, it uncurried only the last `b`.  \nBut this time we will uncurry the whole `C(x, b)` part, which is the last two `x -> b`. And also we will name the right hand side as `atob`\n```haskell\nfromY :: (x -> a) -> (x -> b)\nfromY f -> atob . f\n```\nAnd the conversion is same.\n```haskell\nfromY id :: a -> b\n```","q":"Express the co-Yoneda embedding in Haskell.\n"},"sha1":"52f2e3c84377ddf3b44541fff8760c8ef5e73885","title":"1"},{"attr":{"a":"They make vertical compositions. `(b -> a) . (a -> x) = b -> x`\nIf you know more, please [contribute](https://github.com/ingun37/category-theory-for-programmers-answers).","q":"Yoneda embedding can be used to embed an arbitrary functor category `[C, D]` in the functor category `[[C, D], Set]`. Figure out how it works on morphisms (which in this case are natural transformations).\n"},"sha1":"3e46a66ede6bd872a1f37166f246b2c69a48f511","title":"5"},{"attr":{"a":"Let `A` be a `fromY` function to which `B` is mapped.\nLet `B'` be the `A id` in other words `B'` is `btoa` function to which `A` is mapped.\nNow let `A'` be the `fromY` function to which `B'` is mapped. `A'` must be same to `A` if it's isomorphic.\n```haskell\nA' f b = f (B' b)\n= f (A id b)\n= f (id B b)\n= f (B b)\n```\nIt says `A'` is also mapped from `B` which means `B = B'` which means `A = A'`\n","q":"Show that the bijection we established between `fromY` and `btoa` is an isomorphism (the two mappings are the inverse of each other)."},"sha1":"84b093cb73a2111a728b59ddf2ca1a875f23e93d","title":"2"}],"item":{"attr":{},"sha1":"a9bc30bbce6cf68d02bf600d63dee7049b86dc48","title":"16. Yoneda Embedding"}}