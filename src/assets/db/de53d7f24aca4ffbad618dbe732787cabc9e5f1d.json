{"path":"books/Category Theory For Programmers/14. Representable Functors/4","kids":[],"item":{"attr":{"a":"```haskell\n{-# LANGUAGE TypeFamilies #-}\n\nimport Data.Functor\nimport Data.Functor.Contravariant\n\nclass Representable f where\n    type Rep f :: *\n    tabulate :: (Rep f -> x) -> f x \n    index :: f x -> Rep f -> x\n\ndata Stream x = Cons x (Stream x)\n\ninstance Representable Stream where\n    type Rep Stream = Int\n    tabulate f = Cons (f 0) (tabulate (f . (+1)))\n    index (Cons b bs) n = if n == 0 then b else index bs (n - 1)\n\nindexStream :: Stream x -> Int -> x\nindexStream = index\nsquared :: Int -> Int\nsquared = indexStream (tabulate (^2))\n\nmemoize :: (Int -> a) -> (Int -> a)\nmemoize f = (map f [0 ..] !!)\n\nsqMemo = memoize squared\n\nmain :: IO ()\nmain = print $ sqMemo 10\n```","q":"Using Stream representation, memoize a function that squares its argument.\n"},"sha1":"de53d7f24aca4ffbad618dbe732787cabc9e5f1d","title":"4"}}