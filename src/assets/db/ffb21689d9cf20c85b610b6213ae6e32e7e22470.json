{"parentSha1":"b2a3b650e20b0d34511030969274674aaf259e55","path":"books/Category Theory For Programmers/24. F-Algebras/1","kids":[],"item":{"attr":{"a":"```haskell\nmodule Lib\n    ( alg, RingF(..), calc\n    ) where\nimport Data.Fix\n\ndata RingF a = RZero\n             | ROne\n             | RAdd a a \n             | RMul a a\n             | RNeg a\n\ninstance Functor RingF where\n    fmap f r = case r of\n        RZero -> RZero\n        ROne -> ROne\n        RAdd a b -> RAdd (f a) (f b)\n        RMul a b -> RMul (f a) (f b)\n        RNeg a -> RNeg (f a)\n\ntype Ring = Fix RingF\n\ntake' :: Int -> [Int] -> [Int]\ntake' n l = if n > 0 then case l of [] -> replicate n 0\n                                    (x:xs) -> x:(take' (n-1) xs)\n                     else []\ndegree :: [Int] -> Int\ndegree xs = max 0 $ length xs - 1\n\nalg :: RingF [Int] -> [Int]\nalg RZero = []\nalg ROne = [1]\nalg (RNeg x) = map negate x\nalg (RAdd (x:xs) (y:ys)) = (x+y):(alg $ RAdd xs ys)\nalg (RAdd [] y) = y\nalg (RAdd x []) = x\nalg (RMul x y) = let f :: Int -> Int\n                     f n = let xs = take' (n+1) x\n                               ys = reverse $ take' (n+1) y in\n                                   sum $ zipWith (*) xs ys\n                     in\n                         map f [0..(degree x + degree y)]\n\n```\n\n## Test\n\n```haskell\nimport Lib\nimport Data.Fix\n\nmain :: IO ()\nmain = do\n    print $ cata alg $ Fix (RAdd (Fix ROne) (Fix ROne))\n```\n\n## Result\n```shell\ningun$ stack test\n...\n[2]\n```","q":"Implement the evaluation function for a ring of polynomials of one variable. You can represent a polynomial as a list of coefficients in front of powers of `x`. For instance, $`4x^2-1`$ would be represented as (starting with the zero'th power) `[-1, 0, 4]`."},"sha1":"ffb21689d9cf20c85b610b6213ae6e32e7e22470","title":"1"}}