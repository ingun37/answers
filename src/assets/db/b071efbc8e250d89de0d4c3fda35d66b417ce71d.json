{"parentSha1":"b2a3b650e20b0d34511030969274674aaf259e55","path":"books/Category Theory For Programmers/24. F-Algebras/2","item":{"title":"2","attr":{"q":"Generalize the previous construction to polynomials of many independent variables, like $`x^2y-3y^3z`$.","a":"Just like the book represented univariate polynomial with 1d array, I represented multivariate polynomial with multi-dimension array. But the data structure for multi-dimension array is just a function. The function accepts index value of `[Int]`. You can think of each element represents degree of `x, y, z ...`s. For example, `[0,1,2]` will mean $`x^0y^1z^2`$ (simply $`yz^2`$) and the function will return it's coefficient.\n\nInteresting thing is I used another F-Algebra `Pair`. It's just like the `StreamF` from the book which is used to demonstrate a conversion to List.\n\n```haskell\nmodule NPoly\n    ( bb, alg, NPoly, mulPoly\n    ) where\nimport Data.Fix\nimport Data.Bifunctor\n\ndata RingF a = RZero\n             | ROne\n             | RAdd a a \n             | RMul a a\n             | RNeg a\n\ninstance Functor RingF where\n    fmap f r = case r of\n        RZero -> RZero\n        ROne -> ROne\n        RAdd a b -> RAdd (f a) (f b)\n        RMul a b -> RMul (f a) (f b)\n        RNeg a -> RNeg (f a)\n\ntype NPoly = [Int] -> Int\n\nalg :: RingF NPoly -> NPoly\nalg RZero = const 0\nalg ROne = \\x -> if all (0==) x then 1 else 0\nalg (RAdd f g) = \\x -> (f x) + (g x)\nalg (RMul f1 f2) = mulPoly f1 f2\nalg (RNeg f) = negate . f\n\nmulPoly :: NPoly -> NPoly -> NPoly\nmulPoly f1 f2 = f\n    where f x = sum $ zipWith (*) coef1 coef2\n            where comb = bb x\n                  for1 = comb\n                  for2 = map (zipWith (-) x) for1\n                  coef1 = map f1 for1\n                  coef2 = map f2 for2\n\ndata PairF e = Pair (Maybe (Int, e))\ntype Pair = Fix PairF\n\ninstance Functor PairF where\n    fmap f (Pair e) = Pair $ fmap (second f) e\n\ncartesian :: [Int] -> [Pair] -> [Pair]\ncartesian xs ys = [Fix $ Pair $ Just (x, y) | x <- xs, y <- ys]\n\npairAlg :: PairF [Int] -> [Int]\npairAlg (Pair m) = case m of\n                        Nothing -> []\n                        Just (x, xs) -> x:xs\n\nbb :: [Int] -> [[Int]]\nbb xs = map (cata pairAlg) $ foldr cartesian [Fix $ Pair Nothing] $ map (\\x -> [0..x]) xs\n```\n\n## Test\n\n```haskell\nmodule Main where\n\nimport Data.Fix\nimport qualified NPoly\n\n\nmain :: IO ()\nmain = do\n    let added = cata NPoly.alg $ Fix (RAdd (Fix ROne) (Fix ROne))\n    let multiplied = cata NPoly.alg $ Fix (RMul (Fix ROne) (Fix ROne))\n    let multiplied2 = cata NPoly.alg $ Fix (RMul (Fix ROne) (Fix RZero))\n    let negated = cata NPoly.alg $ Fix (RMul (Fix ROne) (Fix (RNeg (Fix ROne))))\n    print $ square added\n    print $ square multiplied\n    print $ square multiplied2\n    print $ square negated\n\nsquare :: NPoly.NPoly -> [[Int]]\nsquare poly = map f [0..3]\n    where f :: Int -> [Int]\n          f x = map (g x) [0..3]\n            where g :: Int -> Int -> Int\n                  g x y = poly [x,y]\n```\n\n## Result\n```shell\ningun$ stack run\n[[2,0,0],\n [0,0,0],\n [0,0,0]]\n\n[[1,0,0],\n [0,0,0],\n [0,0,0]]\n\n[[0,0,0],\n [0,0,0],\n [0,0,0]]\n\n[[-1,0,0],\n [0,0,0],\n [0,0,0]]\n```\n\nFirst one is identity + identity \nSecond one is identity * identity \nThird one is identity * zero\nFourth one is identity * -identity"},"sha1":"b071efbc8e250d89de0d4c3fda35d66b417ce71d"},"kids":[]}