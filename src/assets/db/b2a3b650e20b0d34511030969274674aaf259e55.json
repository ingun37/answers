{"parentSha1":"b614f31d04b3bc2b3d23ee4337475251429e5a9f","path":"books/Category Theory For Programmers/24. F-Algebras","kids":[{"attr":{"a":"I choosed `Rational` as type of element of Matrix because matrix is over field and rational numbers is field.\n```haskell\nmodule Lib\n    ( alg, RingF(..), matalg\n    ) where\nimport Data.Fix\nimport Data.Matrix\n\ndata RingF a = RZero\n             | ROne\n             | RAdd a a \n             | RMul a a\n             | RNeg a\n\ninstance Functor RingF where\n    fmap f r = case r of\n        RZero -> RZero\n        ROne -> ROne\n        RAdd a b -> RAdd (f a) (f b)\n        RMul a b -> RMul (f a) (f b)\n        RNeg a -> RNeg (f a)\n\ntype Ring = Fix RingF\n\ntype Mat = Matrix Rational\nmatalg :: RingF Mat -> Mat\nmatalg RZero = zero 2 2 \nmatalg ROne = identity 2 \nmatalg (RNeg x) = fmap negate x \nmatalg (RAdd x y) = elementwise (+) x y \nmatalg (RMul x y) = multStd x y \n```\n## Test\n\n```haskell\nmain :: IO ()\nmain = do\n    print $ cata matalg $ Fix (RAdd (Fix ROne) (Fix ROne))\n```\n\n## Result\n\n```shell\ningun$ stack test\n...\n┌             ┐\n│ 2 % 1 0 % 1 │\n│ 0 % 1 2 % 1 │\n└             ┘\n```","q":"Implement the algebra for the ring of 2×2 matrices."},"sha1":"0d15a1d6317b8c7d64b3e919a61a839a97307e7b","title":"3"},{"attr":{"a":"```haskell\nmodule Un\n    ( primes\n    ) where\n\nimport Data.List\n\nprimes :: [Int]\nprimes = unfoldr (\\(prime:remains) -> Just (prime, filter (notdiv prime) remains)) [2..]\n    where notdiv p n = n `mod` p /= 0\n```","q":"Use `unfoldr` to generate a list of the first n primes."},"sha1":"c4ad78b11338182da6d1e6b792987c7319ef55d8","title":"5"},{"attr":{"a":"```haskell\nmodule Rib\n    ( coalg, toListC\n    ) where\nimport Data.Fix\nimport Data.Matrix\n\ndata StreamF a = StreamF Int a\n\ninstance Functor StreamF where\n    fmap f (StreamF n x) = StreamF n (f x)\n\ntype Stream = Fix StreamF\n\ncoalg :: Int -> StreamF Int\ncoalg n = StreamF (n*n) (n+1)\n\ntoListC :: Fix StreamF -> [Int]\ntoListC = cata al where al :: StreamF [Int] -> [Int]\n                        al (StreamF n arr) = n : arr\n```\n## Test\n```haskell\nimport Rib\nimport Data.Fix\n\nmain :: IO ()\nmain = do\n    print $ take 5 $ toListC $ ana coalg 1\n```\n## Result\n```shell\ningun$ stack test\n...\n[1,4,9,16,25]\n```","q":"Define a coalgebra whose anamorphism produces a list of squares of natural numbers."},"sha1":"d7db2503b0a0bdc85006bbcbb1db5ce0677e8d6f","title":"4"},{"attr":{"a":"```haskell\nmodule Lib\n    ( alg, RingF(..), calc\n    ) where\nimport Data.Fix\n\ndata RingF a = RZero\n             | ROne\n             | RAdd a a \n             | RMul a a\n             | RNeg a\n\ninstance Functor RingF where\n    fmap f r = case r of\n        RZero -> RZero\n        ROne -> ROne\n        RAdd a b -> RAdd (f a) (f b)\n        RMul a b -> RMul (f a) (f b)\n        RNeg a -> RNeg (f a)\n\ntype Ring = Fix RingF\n\ntake' :: Int -> [Int] -> [Int]\ntake' n l = if n > 0 then case l of [] -> replicate n 0\n                                    (x:xs) -> x:(take' (n-1) xs)\n                     else []\ndegree :: [Int] -> Int\ndegree xs = max 0 $ length xs - 1\n\nalg :: RingF [Int] -> [Int]\nalg RZero = []\nalg ROne = [1]\nalg (RNeg x) = map negate x\nalg (RAdd (x:xs) (y:ys)) = (x+y):(alg $ RAdd xs ys)\nalg (RAdd [] y) = y\nalg (RAdd x []) = x\nalg (RMul x y) = let f :: Int -> Int\n                     f n = let xs = take' (n+1) x\n                               ys = reverse $ take' (n+1) y in\n                                   sum $ zipWith (*) xs ys\n                     in\n                         map f [0..(degree x + degree y)]\n\n```\n\n## Test\n\n```haskell\nimport Lib\nimport Data.Fix\n\nmain :: IO ()\nmain = do\n    print $ cata alg $ Fix (RAdd (Fix ROne) (Fix ROne))\n```\n\n## Result\n```shell\ningun$ stack test\n...\n[2]\n```","q":"Implement the evaluation function for a ring of polynomials of one variable. You can represent a polynomial as a list of coefficients in front of powers of `x`. For instance, $4x^2-1$ would be represented as (starting with the zero’th power) `[-1, 0, 4]`."},"sha1":"ffb21689d9cf20c85b610b6213ae6e32e7e22470","title":"1"}],"item":{"attr":{},"sha1":"b2a3b650e20b0d34511030969274674aaf259e55","title":"24. F-Algebras"}}