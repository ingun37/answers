{"path":"books/Category Theory For Programmers/15. The Yoneda Lemma","kids":[{"attr":{"a":"The `C(a, -)` functor must be mapping a into singleton set and every other into empty set. So natural transformation must be looking like singleton set `C(a, a)` selecting an object in `F a` while any other objects are transformed via absurd function.\n","q":"A discrete category is one that has objects but no morphisms other than identity morphisms. How does the Yoneda lemma work for functors from such a category?"},"sha1":"fc309244323dc5aa921f2811bd66f2dcef2d1d15","title":"2"},{"attr":{"a":"If you give `()` as a to Yoneda lemma for the list functor, you get set of natural transformations from `C((), -)` to List that are isomorphic to `[()]`. So the data type of the natural transformations `(()âx)â[x]` could be another representation.","q":"A list of units `[()]` contains no other information but its length. So, as a data type, it can be considered an encoding of integers. An empty list encodes zero, a singleton `[()]` (a value, not a type) encodes one, and so on. Construct another representation of this data type using the Yoneda lemma for the list functor.\n"},"sha1":"99b035e620cbb431163eb907122670b5eb621b50","title":"3"},{"attr":{"a":"let `psiâ fa = (flip fmap) fa` so `psi` and `phi`âs each input/output type match. (flip swaps the order of parameters)\n\n```haskell\nphi (psiâ fa)\n= (psiâ fa) id\n= ((flip fmap) fa) id\n= fmap id fa\n= fa\n```","q":"Show that the two functions `phi` and `psi` that form the Yoneda isomorphism in Haskell are inverses of each other.\n\n```haskell\nphi :: (forall x . (a -> x) -> F x) -> F a\nphi alpha = alpha id\n```\n\n```haskell\npsi :: F a -> (forall x . (a -> x) -> F x)\npsi fa h = fmap h fa\n```"},"sha1":"6ad7720ca8496d9551054a91a03f4954c229303b","title":"1"}],"item":{"attr":{},"sha1":"9d74a7917a46fd36d8008543345c3449dfd588f4","title":"15. The Yoneda Lemma"}}